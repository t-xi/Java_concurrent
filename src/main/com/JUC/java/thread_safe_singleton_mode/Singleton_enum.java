package thread_safe_singleton_mode;

/**
 * @ClassName :   Singleton_enum
 * @Description: TODO
 * @Author: TX
 * @CreateDate: 2021/10/21 13:08
 * @Version: 1.0
 */
// 问题1：枚举单例是如何限制实例个数的：创建枚举类的时候就已经定义好了，每个枚举常量其实就是枚举类的一个静态成员变量
// 问题2：枚举单例在创建时是否有并发问题：没有，这是静态成员变量
// 问题3：枚举单例能否被反射破坏单例：不能
// 问题4：枚举单例能否被反序列化破坏单例：枚举类默认实现了序列化接口，枚举类已经考虑到此问题，无需担心破坏单例
// 问题5：枚举单例属于懒汉式还是饿汉式：饿汉式
// 问题6：枚举单例如果希望加入一些单例创建时的初始化逻辑该如何做：加构造方法就行了

enum Singleton_enum {
    INSTANCE;
}
//问题1 : 枚举类中, 只有一个INSTANCE, 就确保了它是单例的
//问题2 : 没有并发问题, 是线程安全的, 因为枚举单例底层是一个静态成员变量, 它是通过类加载器的加载而创建的, 确保了线程安全
//问题3 : 反射无法破坏枚举单例, 主要通过反射, newInstance的时候, 会在该方法中作判断, 如果检查是枚举类型, 就会抛出异常。
//
//      if ((this.clazz.getModifiers() & 16384) != 0)
//      throw new IllegalArgumentException(“Cannot reflectively create enum objects”);
//
//问题4 : 反序列化不能破坏, 枚举类默认也实习了序列号接口. 但枚举类考虑到了这个问题, 不会破坏单例. 通过反序列化得到的并不是同一个单例对象; 除此之外, 还可以写上readResolve方法,
//问题 5 : 属于饿汉式, 静态成员变量, 通过类加载器的时候就加载了。
//问题 6 : 加构造方法

